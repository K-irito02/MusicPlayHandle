# Qt6音频播放器多线程设计文档 v0.1

## 1. 多线程架构概述

### 1.1 线程模型设计

```
┌─────────────────────────────────────────────────────────────────┐
│                        主线程 (UI Thread)                      │
│  MainWindow | PlayInterface | ManageTab | 事件处理 | 界面更新    │
└─────────────────────────┬───────────────────────────────────────┘
                         │
    ┌────────────────────┴────────────────────┐
    │                                         │
┌───▼────────────────────┐          ┌────────▼───────────────────┐
│    音频处理线程         │          │     数据库操作线程          │
│ AudioWorkerThread      │          │  DatabaseWorkerThread      │
│ • 音频播放控制         │          │ • 歌曲CRUD操作             │
│ • 音频格式解码         │          │ • 标签管理                 │
│ • 音效处理             │          │ • 播放历史记录             │
│ • 音频数据缓冲         │          │ • 设置存储                 │
└────────────────────────┘          └────────────────────────────┘
            │                                    │
    ┌───────▼────────────┐              ┌───────▼────────────────┐
    │   音频分析线程      │              │    文件I/O线程          │
    │ AudioAnalysisThread│              │  FileIOWorkerThread    │
    │ • 频谱分析         │              │ • 文件扫描             │
    │ • 波形计算         │              │ • 元数据提取           │
    │ • VU表计算         │              │ • 封面图片加载         │
    │ • 音频可视化       │              │ • 歌词文件读取         │
    └────────────────────┘              └────────────────────────┘
            │                                    │
    ┌───────▼────────────┐              ┌───────▼────────────────┐
    │   缓存管理线程      │              │    插件管理线程         │
    │ CacheManagerThread │              │  PluginManagerThread   │
    │ • 音频数据缓存     │              │ • 插件加载卸载         │
    │ • 频谱数据缓存     │              │ • 插件状态监控         │
    │ • 封面图片缓存     │              │ • 插件通信             │
    │ • 缓存清理         │              │ • 插件异常处理         │
    └────────────────────┘              └────────────────────────┘
```

### 1.2 线程职责分工

| 线程类型 | 主要职责 | 优先级 | 生命周期 |
|---------|----------|--------|----------|
| 主线程 | UI处理、事件分发、界面更新 | 高 | 应用程序整个生命周期 |
| 音频处理线程 | 音频播放、解码、效果处理 | 高 | 音频引擎启动-关闭 |
| 数据库操作线程 | 数据库读写、事务处理 | 中 | 应用程序整个生命周期 |
| 音频分析线程 | 频谱分析、可视化计算 | 中 | 播放时启动 |
| 文件I/O线程 | 文件读写、元数据提取 | 低 | 按需启动 |
| 缓存管理线程 | 缓存策略、内存管理 | 低 | 后台常驻 |
| 插件管理线程 | 插件生命周期管理 | 低 | 插件系统启动时 |

## 2. 核心线程设计

### 2.1 主线程 (UI Thread)

#### 2.1.1 主线程管理器
```cpp
class MainThreadManager : public QObject {
    Q_OBJECT
    
public:
    static MainThreadManager* instance();
    
    // 线程安全的UI更新调度
    void scheduleUIUpdate(std::function<void()> updateFunction);
    void scheduleUIUpdateDelayed(std::function<void()> updateFunction, int delayMs);
    
    // 批量UI更新
    void batchUIUpdates(const QList<std::function<void()>>& updates);
    
    // UI事件处理
    void handlePlaybackEvent(const PlaybackEvent& event);
    void handleDatabaseEvent(const DatabaseEvent& event);
    void handleFileEvent(const FileEvent& event);
    
signals:
    void uiUpdateRequested();
    void eventProcessed(const QString& eventType);
    
private:
    MainThreadManager(QObject* parent = nullptr);
    static MainThreadManager* m_instance;
    
    QTimer* m_uiUpdateTimer;
    QQueue<std::function<void()>> m_uiUpdateQueue;
    QMutex m_uiUpdateMutex;
    
    void processUIUpdates();
};
```

#### 2.1.2 线程安全的UI更新机制
```cpp
class ThreadSafeUIUpdater {
public:
    // 线程安全的进度条更新
    static void updateProgressBar(QProgressBar* progressBar, int value) {
        QMetaObject::invokeMethod(progressBar, [progressBar, value]() {
            progressBar->setValue(value);
        }, Qt::QueuedConnection);
    }
    
    // 线程安全的文本更新
    static void updateLabel(QLabel* label, const QString& text) {
        QMetaObject::invokeMethod(label, [label, text]() {
            label->setText(text);
        }, Qt::QueuedConnection);
    }
    
    // 线程安全的列表更新
    static void updateListWidget(QListWidget* listWidget, const QStringList& items) {
        QMetaObject::invokeMethod(listWidget, [listWidget, items]() {
            listWidget->clear();
            listWidget->addItems(items);
        }, Qt::QueuedConnection);
    }
    
    // 线程安全的状态栏更新
    static void updateStatusBar(QStatusBar* statusBar, const QString& message, int timeout = 0) {
        QMetaObject::invokeMethod(statusBar, [statusBar, message, timeout]() {
            statusBar->showMessage(message, timeout);
        }, Qt::QueuedConnection);
    }
};
```

### 2.2 音频处理线程

#### 2.2.1 音频工作线程
```cpp
class AudioWorkerThread : public QThread {
    Q_OBJECT
    
public:
    explicit AudioWorkerThread(QObject* parent = nullptr);
    ~AudioWorkerThread();
    
    // 播放控制
    void playAudio(const QString& filePath);
    void pauseAudio();
    void resumeAudio();
    void stopAudio();
    void seekAudio(qint64 position);
    
    // 音量控制
    void setVolume(int volume);
    void setMuted(bool muted);
    
    // 音效处理
    void setEqualizerSettings(const QVector<double>& settings);
    void enableReverb(bool enabled, double intensity);
    void setCrossfadeDuration(int duration);
    
protected:
    void run() override;
    
signals:
    void audioLoaded(const Song& song);
    void playbackStarted();
    void playbackPaused();
    void playbackStopped();
    void positionChanged(qint64 position);
    void durationChanged(qint64 duration);
    void volumeChanged(int volume);
    void audioError(const QString& error);
    void bufferStatusChanged(int percentage);
    
private slots:
    void handlePlayRequest(const QString& filePath);
    void handlePauseRequest();
    void handleStopRequest();
    void handleSeekRequest(qint64 position);
    void handleVolumeRequest(int volume);
    
private:
    QMediaPlayer* m_mediaPlayer;
    QAudioOutput* m_audioOutput;
    QAudioSink* m_audioSink;
    
    // 音频缓冲区
    QBuffer* m_audioBuffer;
    QByteArray m_audioData;
    
    // 音效处理器
    std::unique_ptr<AudioEffectProcessor> m_effectProcessor;
    
    // 线程同步
    QMutex m_audioMutex;
    QWaitCondition m_audioCondition;
    
    // 状态管理
    AudioState m_currentState;
    QString m_currentFilePath;
    qint64 m_currentPosition;
    qint64 m_currentDuration;
    
    void initializeAudioSystem();
    void cleanupAudioSystem();
    void processAudioCommands();
    void updatePlaybackPosition();
    
    // 音频数据处理
    QByteArray loadAudioFile(const QString& filePath);
    QByteArray applyAudioEffects(const QByteArray& audioData);
    void bufferAudioData(const QByteArray& audioData);
};
```

#### 2.2.2 音频解码器线程池
```cpp
class AudioDecoderThreadPool : public QObject {
    Q_OBJECT
    
public:
    static AudioDecoderThreadPool* instance();
    
    // 异步解码
    void decodeAudioFile(const QString& filePath, int priority = 0);
    void decodeAudioBatch(const QStringList& filePaths);
    
    // 预加载
    void preloadAudioFile(const QString& filePath);
    void preloadPlaylist(const QStringList& filePaths);
    
    // 线程池管理
    void setMaxThreadCount(int maxThreads);
    int maxThreadCount() const;
    int activeThreadCount() const;
    
signals:
    void audioDecoded(const QString& filePath, const QByteArray& audioData);
    void batchDecoded(const QStringList& filePaths);
    void decodingError(const QString& filePath, const QString& error);
    void decodingProgress(const QString& filePath, int percentage);
    
private:
    AudioDecoderThreadPool(QObject* parent = nullptr);
    static AudioDecoderThreadPool* m_instance;
    
    QThreadPool* m_threadPool;
    QHash<QString, QFuture<void>> m_decodingTasks;
    QMutex m_taskMutex;
    
    void setupThreadPool();
    void cleanupThreadPool();
};

// 音频解码任务
class AudioDecodeTask : public QRunnable {
public:
    AudioDecodeTask(const QString& filePath, AudioDecoderThreadPool* pool);
    
    void run() override;
    
private:
    QString m_filePath;
    AudioDecoderThreadPool* m_pool;
    
    QByteArray decodeFile(const QString& filePath);
    void extractMetadata(const QString& filePath, Song& song);
};
```

### 2.3 数据库操作线程

#### 2.3.1 数据库工作线程
```cpp
class DatabaseWorkerThread : public QThread {
    Q_OBJECT
    
public:
    explicit DatabaseWorkerThread(QObject* parent = nullptr);
    ~DatabaseWorkerThread();
    
    // 歌曲操作
    void insertSong(const Song& song);
    void updateSong(const Song& song);
    void deleteSong(int songId);
    void querySongs(const QString& condition = QString());
    void querySongsByTag(int tagId);
    
    // 标签操作
    void insertTag(const Tag& tag);
    void updateTag(const Tag& tag);
    void deleteTag(int tagId);
    void queryTags();
    
    // 播放历史
    void insertPlayHistory(const PlayHistory& history);
    void queryPlayHistory(int limit = 100);
    void clearPlayHistory();
    
    // 设置操作
    void saveSetting(const QString& key, const QVariant& value);
    void loadSetting(const QString& key);
    void loadAllSettings();
    
    // 事务操作
    void beginTransaction();
    void commitTransaction();
    void rollbackTransaction();
    
protected:
    void run() override;
    
signals:
    void songInserted(const Song& song);
    void songUpdated(const Song& song);
    void songDeleted(int songId);
    void songsQueried(const QList<Song>& songs);
    
    void tagInserted(const Tag& tag);
    void tagUpdated(const Tag& tag);
    void tagDeleted(int tagId);
    void tagsQueried(const QList<Tag>& tags);
    
    void playHistoryInserted(const PlayHistory& history);
    void playHistoryQueried(const QList<PlayHistory>& history);
    
    void settingSaved(const QString& key, const QVariant& value);
    void settingLoaded(const QString& key, const QVariant& value);
    void allSettingsLoaded(const QVariantMap& settings);
    
    void transactionCompleted(bool success);
    void databaseError(const QString& error);
    
private slots:
    void handleDatabaseOperation(const DatabaseOperation& operation);
    
private:
    DatabaseManager* m_dbManager;
    QQueue<DatabaseOperation> m_operationQueue;
    QMutex m_operationMutex;
    QWaitCondition m_operationCondition;
    
    bool m_running;
    bool m_inTransaction;
    
    void processDatabaseOperations();
    void executeDatabaseOperation(const DatabaseOperation& operation);
    void handleDatabaseError(const QString& error);
    
    // 具体操作实现
    void performSongInsert(const Song& song);
    void performSongUpdate(const Song& song);
    void performSongDelete(int songId);
    void performSongQuery(const QString& condition);
    
    void performTagInsert(const Tag& tag);
    void performTagUpdate(const Tag& tag);
    void performTagDelete(int tagId);
    void performTagQuery();
    
    void performPlayHistoryInsert(const PlayHistory& history);
    void performPlayHistoryQuery(int limit);
    
    void performSettingSave(const QString& key, const QVariant& value);
    void performSettingLoad(const QString& key);
    void performAllSettingsLoad();
};
```

#### 2.3.2 数据库连接池
```cpp
class DatabaseConnectionPool : public QObject {
    Q_OBJECT
    
public:
    static DatabaseConnectionPool* instance();
    
    // 连接管理
    QSqlDatabase getConnection(const QString& connectionName = QString());
    void releaseConnection(const QString& connectionName);
    
    // 连接池配置
    void setMaxConnections(int maxConnections);
    void setConnectionTimeout(int timeoutMs);
    
    // 连接状态
    int activeConnections() const;
    int idleConnections() const;
    bool isHealthy() const;
    
    // 连接池维护
    void cleanupIdleConnections();
    void testConnections();
    
signals:
    void connectionCreated(const QString& connectionName);
    void connectionReleased(const QString& connectionName);
    void connectionError(const QString& error);
    
private:
    DatabaseConnectionPool(QObject* parent = nullptr);
    static DatabaseConnectionPool* m_instance;
    
    struct ConnectionInfo {
        QSqlDatabase database;
        QDateTime lastUsed;
        bool inUse;
        QThread* thread;
    };
    
    QMap<QString, ConnectionInfo> m_connections;
    QMutex m_connectionMutex;
    
    int m_maxConnections;
    int m_connectionTimeout;
    int m_nextConnectionId;
    
    QString createConnectionName();
    void createConnection(const QString& connectionName);
    void removeConnection(const QString& connectionName);
    bool isConnectionValid(const QString& connectionName);
};
```

### 2.4 音频分析线程

#### 2.4.1 音频分析工作线程
```cpp
class AudioAnalysisThread : public QThread {
    Q_OBJECT
    
public:
    explicit AudioAnalysisThread(QObject* parent = nullptr);
    ~AudioAnalysisThread();
    
    // 分析控制
    void startAnalysis(const QByteArray& audioData);
    void stopAnalysis();
    void pauseAnalysis();
    void resumeAnalysis();
    
    // 分析配置
    void setAnalysisMode(AnalysisMode mode);
    void setSpectrumBands(int bands);
    void setUpdateInterval(int intervalMs);
    void setWindowSize(int size);
    
    // 可视化设置
    void enableSpectrum(bool enabled);
    void enableWaveform(bool enabled);
    void enableVUMeter(bool enabled);
    
protected:
    void run() override;
    
signals:
    void spectrumDataReady(const QVector<double>& spectrum);
    void waveformDataReady(const QVector<double>& waveform);
    void vuMeterDataReady(double leftLevel, double rightLevel);
    void peakDetected(double peak);
    void analysisError(const QString& error);
    
private slots:
    void processAudioData();
    void updateAnalysisSettings();
    
private:
    // 分析状态
    AnalysisMode m_analysisMode;
    bool m_running;
    bool m_paused;
    bool m_spectrumEnabled;
    bool m_waveformEnabled;
    bool m_vuMeterEnabled;
    
    // 分析参数
    int m_spectrumBands;
    int m_updateInterval;
    int m_windowSize;
    int m_sampleRate;
    
    // 音频数据缓冲
    QByteArray m_audioData;
    QCircularBuffer<double> m_sampleBuffer;
    QMutex m_dataMutex;
    
    // 分析算法
    std::unique_ptr<FFTAnalyzer> m_fftAnalyzer;
    std::unique_ptr<WaveformAnalyzer> m_waveformAnalyzer;
    std::unique_ptr<VUMeterAnalyzer> m_vuMeterAnalyzer;
    
    // 结果缓存
    QVector<double> m_spectrumData;
    QVector<double> m_waveformData;
    double m_leftLevel;
    double m_rightLevel;
    
    void initializeAnalyzers();
    void cleanupAnalyzers();
    void analyzeSpectrum();
    void analyzeWaveform();
    void analyzeVUMeter();
    void emitAnalysisResults();
    
    // 音频数据处理
    QVector<double> convertToSamples(const QByteArray& audioData);
    void applyWindow(QVector<double>& samples);
    void normalizeSpectrum(QVector<double>& spectrum);
};
```

#### 2.4.2 FFT分析器
```cpp
class FFTAnalyzer : public QObject {
    Q_OBJECT
    
public:
    explicit FFTAnalyzer(int sampleRate, int windowSize, QObject* parent = nullptr);
    ~FFTAnalyzer();
    
    // FFT分析
    QVector<double> analyze(const QVector<double>& samples);
    void setWindowFunction(WindowFunction function);
    void setBandCount(int bands);
    
    // 频率映射
    QVector<double> mapToFrequencyBands(const QVector<double>& fftData);
    double frequencyForBin(int bin) const;
    int binForFrequency(double frequency) const;
    
private:
    int m_sampleRate;
    int m_windowSize;
    int m_bandCount;
    WindowFunction m_windowFunction;
    
    // FFT实现
    void* m_fftPlan;  // FFTW plan
    double* m_inputBuffer;
    fftw_complex* m_outputBuffer;
    
    QVector<double> m_windowCoefficients;
    QVector<double> m_frequencyBands;
    
    void initializeFFT();
    void cleanupFFT();
    void calculateWindowCoefficients();
    void calculateFrequencyBands();
    
    // 窗函数实现
    void applyHammingWindow(QVector<double>& samples);
    void applyHannWindow(QVector<double>& samples);
    void applyBlackmanWindow(QVector<double>& samples);
};
```

### 2.5 文件I/O线程

#### 2.5.1 文件I/O工作线程
```cpp
class FileIOWorkerThread : public QThread {
    Q_OBJECT
    
public:
    explicit FileIOWorkerThread(QObject* parent = nullptr);
    ~FileIOWorkerThread();
    
    // 文件操作
    void scanDirectory(const QString& directory, bool recursive = true);
    void loadAudioFile(const QString& filePath);
    void loadAudioFiles(const QStringList& filePaths);
    void loadAlbumArt(const QString& filePath);
    void loadLyrics(const QString& filePath);
    
    // 元数据操作
    void extractMetadata(const QString& filePath);
    void extractMetadataBatch(const QStringList& filePaths);
    void saveMetadata(const QString& filePath, const QVariantMap& metadata);
    
    // 文件监控
    void startFileWatcher(const QStringList& directories);
    void stopFileWatcher();
    
protected:
    void run() override;
    
signals:
    void directoryScanned(const QString& directory, const QStringList& audioFiles);
    void audioFileLoaded(const QString& filePath, const QByteArray& audioData);
    void albumArtLoaded(const QString& filePath, const QPixmap& artwork);
    void lyricsLoaded(const QString& filePath, const QString& lyrics);
    void metadataExtracted(const QString& filePath, const QVariantMap& metadata);
    void metadataSaved(const QString& filePath);
    void fileChanged(const QString& filePath);
    void fileError(const QString& filePath, const QString& error);
    void operationProgress(int current, int total);
    
private slots:
    void handleFileOperation(const FileOperation& operation);
    void onFileChanged(const QString& filePath);
    void onDirectoryChanged(const QString& directory);
    
private:
    QQueue<FileOperation> m_operationQueue;
    QMutex m_operationMutex;
    QWaitCondition m_operationCondition;
    
    QFileSystemWatcher* m_fileWatcher;
    QStringList m_watchedDirectories;
    
    // 支持的音频格式
    QStringList m_supportedFormats;
    
    // 操作状态
    bool m_running;
    int m_currentOperation;
    int m_totalOperations;
    
    void processFileOperations();
    void executeFileOperation(const FileOperation& operation);
    
    // 具体操作实现
    void performDirectoryScan(const QString& directory, bool recursive);
    void performFileLoad(const QString& filePath);
    void performAlbumArtLoad(const QString& filePath);
    void performLyricsLoad(const QString& filePath);
    void performMetadataExtract(const QString& filePath);
    void performMetadataSave(const QString& filePath, const QVariantMap& metadata);
    
    // 辅助函数
    QStringList findAudioFiles(const QString& directory, bool recursive);
    bool isAudioFile(const QString& filePath);
    QPixmap extractAlbumArt(const QString& filePath);
    QString extractLyrics(const QString& filePath);
    QVariantMap extractFileMetadata(const QString& filePath);
};
```

### 2.6 缓存管理线程

#### 2.6.1 缓存管理工作线程
```cpp
class CacheManagerThread : public QThread {
    Q_OBJECT
    
public:
    explicit CacheManagerThread(QObject* parent = nullptr);
    ~CacheManagerThread();
    
    // 缓存操作
    void cacheAudioData(const QString& filePath, const QByteArray& audioData);
    void cacheSpectrumData(const QString& filePath, const QVector<double>& spectrum);
    void cacheAlbumArt(const QString& filePath, const QPixmap& artwork);
    void cacheMetadata(const QString& filePath, const QVariantMap& metadata);
    
    // 缓存查询
    void getCachedAudioData(const QString& filePath);
    void getCachedSpectrumData(const QString& filePath);
    void getCachedAlbumArt(const QString& filePath);
    void getCachedMetadata(const QString& filePath);
    
    // 缓存管理
    void clearCache();
    void clearCacheForFile(const QString& filePath);
    void compactCache();
    void setCacheSize(int maxSizeInMB);
    
protected:
    void run() override;
    
signals:
    void audioDataCached(const QString& filePath);
    void spectrumDataCached(const QString& filePath);
    void albumArtCached(const QString& filePath);
    void metadataCached(const QString& filePath);
    
    void cachedAudioDataReady(const QString& filePath, const QByteArray& audioData);
    void cachedSpectrumDataReady(const QString& filePath, const QVector<double>& spectrum);
    void cachedAlbumArtReady(const QString& filePath, const QPixmap& artwork);
    void cachedMetadataReady(const QString& filePath, const QVariantMap& metadata);
    
    void cacheCleared();
    void cacheCompacted();
    void cacheError(const QString& error);
    
private slots:
    void handleCacheOperation(const CacheOperation& operation);
    void performCacheCleanup();
    
private:
    QQueue<CacheOperation> m_operationQueue;
    QMutex m_operationMutex;
    QWaitCondition m_operationCondition;
    
    // 缓存存储
    QCache<QString, QByteArray> m_audioCache;
    QCache<QString, QVector<double>> m_spectrumCache;
    QCache<QString, QPixmap> m_albumArtCache;
    QCache<QString, QVariantMap> m_metadataCache;
    
    // 缓存配置
    int m_maxCacheSize;
    int m_currentCacheSize;
    QString m_cacheDirectory;
    
    // 清理定时器
    QTimer* m_cleanupTimer;
    
    bool m_running;
    
    void processCacheOperations();
    void executeCacheOperation(const CacheOperation& operation);
    
    // 具体操作实现
    void performAudioDataCache(const QString& filePath, const QByteArray& audioData);
    void performSpectrumDataCache(const QString& filePath, const QVector<double>& spectrum);
    void performAlbumArtCache(const QString& filePath, const QPixmap& artwork);
    void performMetadataCache(const QString& filePath, const QVariantMap& metadata);
    
    void performAudioDataRetrieval(const QString& filePath);
    void performSpectrumDataRetrieval(const QString& filePath);
    void performAlbumArtRetrieval(const QString& filePath);
    void performMetadataRetrieval(const QString& filePath);
    
    // 缓存管理
    void evictLeastRecentlyUsed();
    void updateCacheStatistics();
    void persistCache();
    void loadPersistedCache();
};
```

## 3. 线程间通信机制

### 3.1 信号槽通信

#### 3.1.1 线程安全的信号槽连接
```cpp
class ThreadSafeConnector : public QObject {
    Q_OBJECT
    
public:
    static ThreadSafeConnector* instance();
    
    // 跨线程连接管理
    template<typename Sender, typename Signal, typename Receiver, typename Slot>
    QMetaObject::Connection connectThreadSafe(
        const Sender* sender, Signal signal,
        const Receiver* receiver, Slot slot,
        Qt::ConnectionType type = Qt::QueuedConnection) {
        return connect(sender, signal, receiver, slot, type);
    }
    
    // 连接状态监控
    void monitorConnection(const QMetaObject::Connection& connection, const QString& name);
    void removeConnectionMonitor(const QMetaObject::Connection& connection);
    
    // 连接健康检查
    void checkConnectionHealth();
    bool isConnectionHealthy(const QMetaObject::Connection& connection);
    
signals:
    void connectionBroken(const QString& connectionName);
    void connectionHealthy(const QString& connectionName);
    
private:
    ThreadSafeConnector(QObject* parent = nullptr);
    static ThreadSafeConnector* m_instance;
    
    struct ConnectionInfo {
        QMetaObject::Connection connection;
        QString name;
        QDateTime lastActivity;
        bool isHealthy;
    };
    
    QMap<QMetaObject::Connection, ConnectionInfo> m_connections;
    QMutex m_connectionMutex;
    QTimer* m_healthCheckTimer;
    
    void performHealthCheck();
};
```

#### 3.1.2 事件总线系统
```cpp
class ThreadSafeEventBus : public QObject {
    Q_OBJECT
    
public:
    static ThreadSafeEventBus* instance();
    
    // 事件发布
    void publishEvent(const QString& eventType, const QVariant& eventData);
    void publishEventDelayed(const QString& eventType, const QVariant& eventData, int delayMs);
    
    // 事件订阅
    void subscribeToEvent(const QString& eventType, QObject* subscriber, const char* slot);
    void unsubscribeFromEvent(const QString& eventType, QObject* subscriber);
    void unsubscribeAll(QObject* subscriber);
    
    // 事件过滤
    void setEventFilter(const QString& eventType, std::function<bool(const QVariant&)> filter);
    void removeEventFilter(const QString& eventType);
    
    // 事件统计
    int getEventCount(const QString& eventType) const;
    QStringList getActiveEventTypes() const;
    
signals:
    void eventPublished(const QString& eventType, const QVariant& eventData);
    void eventDelivered(const QString& eventType, QObject* subscriber);
    void eventFiltered(const QString& eventType, const QVariant& eventData);
    
private:
    ThreadSafeEventBus(QObject* parent = nullptr);
    static ThreadSafeEventBus* m_instance;
    
    struct EventSubscription {
        QObject* subscriber;
        const char* slot;
        QThread* thread;
    };
    
    QMultiMap<QString, EventSubscription> m_subscriptions;
    QMap<QString, std::function<bool(const QVariant&)>> m_filters;
    QMap<QString, int> m_eventCounts;
    
    QMutex m_subscriptionMutex;
    QMutex m_filterMutex;
    QMutex m_countMutex;
    
    void deliverEvent(const QString& eventType, const QVariant& eventData);
    bool shouldDeliverEvent(const QString& eventType, const QVariant& eventData);
    void cleanupSubscriptions();
};
```

### 3.2 消息队列机制

#### 3.2.1 线程安全消息队列
```cpp
template<typename T>
class ThreadSafeQueue {
public:
    ThreadSafeQueue() : m_shutdown(false) {}
    
    void enqueue(const T& item) {
        QMutexLocker locker(&m_mutex);
        if (!m_shutdown) {
            m_queue.enqueue(item);
            m_condition.wakeOne();
        }
    }
    
    bool dequeue(T& item, int timeoutMs = -1) {
        QMutexLocker locker(&m_mutex);
        
        if (m_queue.isEmpty() && !m_shutdown) {
            if (timeoutMs < 0) {
                m_condition.wait(&m_mutex);
            } else {
                if (!m_condition.wait(&m_mutex, timeoutMs)) {
                    return false; // 超时
                }
            }
        }
        
        if (!m_queue.isEmpty()) {
            item = m_queue.dequeue();
            return true;
        }
        
        return false; // 队列关闭
    }
    
    bool tryDequeue(T& item) {
        QMutexLocker locker(&m_mutex);
        if (!m_queue.isEmpty()) {
            item = m_queue.dequeue();
            return true;
        }
        return false;
    }
    
    void clear() {
        QMutexLocker locker(&m_mutex);
        m_queue.clear();
    }
    
    int size() const {
        QMutexLocker locker(&m_mutex);
        return m_queue.size();
    }
    
    bool isEmpty() const {
        QMutexLocker locker(&m_mutex);
        return m_queue.isEmpty();
    }
    
    void shutdown() {
        QMutexLocker locker(&m_mutex);
        m_shutdown = true;
        m_condition.wakeAll();
    }
    
private:
    mutable QMutex m_mutex;
    QWaitCondition m_condition;
    QQueue<T> m_queue;
    bool m_shutdown;
};
```

#### 3.2.2 优先级消息队列
```cpp
template<typename T>
class PriorityMessageQueue {
public:
    enum Priority {
        High = 0,
        Normal = 1,
        Low = 2
    };
    
    PriorityMessageQueue() : m_shutdown(false) {}
    
    void enqueue(const T& message, Priority priority = Normal) {
        QMutexLocker locker(&m_mutex);
        if (!m_shutdown) {
            m_queues[priority].enqueue(message);
            m_condition.wakeOne();
        }
    }
    
    bool dequeue(T& message, int timeoutMs = -1) {
        QMutexLocker locker(&m_mutex);
        
        while (allQueuesEmpty() && !m_shutdown) {
            if (timeoutMs < 0) {
                m_condition.wait(&m_mutex);
            } else {
                if (!m_condition.wait(&m_mutex, timeoutMs)) {
                    return false; // 超时
                }
            }
        }
        
        // 按优先级处理消息
        for (int i = High; i <= Low; ++i) {
            if (!m_queues[i].isEmpty()) {
                message = m_queues[i].dequeue();
                return true;
            }
        }
        
        return false; // 队列关闭
    }
    
    void clear() {
        QMutexLocker locker(&m_mutex);
        for (int i = High; i <= Low; ++i) {
            m_queues[i].clear();
        }
    }
    
    int size() const {
        QMutexLocker locker(&m_mutex);
        int total = 0;
        for (int i = High; i <= Low; ++i) {
            total += m_queues[i].size();
        }
        return total;
    }
    
    void shutdown() {
        QMutexLocker locker(&m_mutex);
        m_shutdown = true;
        m_condition.wakeAll();
    }
    
private:
    mutable QMutex m_mutex;
    QWaitCondition m_condition;
    QQueue<T> m_queues[3]; // High, Normal, Low
    bool m_shutdown;
    
    bool allQueuesEmpty() const {
        for (int i = High; i <= Low; ++i) {
            if (!m_queues[i].isEmpty()) {
                return false;
            }
        }
        return true;
    }
};
```

## 4. 同步机制设计

### 4.1 读写锁

#### 4.1.1 歌曲数据读写锁
```cpp
class SongDataManager : public QObject {
    Q_OBJECT
    
public:
    static SongDataManager* instance();
    
    // 读操作
    Song getSong(int songId) const;
    QList<Song> getAllSongs() const;
    QList<Song> getSongsByTag(int tagId) const;
    bool songExists(int songId) const;
    
    // 写操作
    void addSong(const Song& song);
    void updateSong(const Song& song);
    void removeSong(int songId);
    void addSongs(const QList<Song>& songs);
    void removeAllSongs();
    
    // 批量操作
    void batchUpdate(const QList<Song>& songs);
    void batchRemove(const QList<int>& songIds);
    
signals:
    void songAdded(const Song& song);
    void songUpdated(const Song& song);
    void songRemoved(int songId);
    void songsCleared();
    
private:
    SongDataManager(QObject* parent = nullptr);
    static SongDataManager* m_instance;
    
    mutable QReadWriteLock m_songsLock;
    QMap<int, Song> m_songs;
    QMultiMap<int, int> m_tagSongMap; // tagId -> songId
    
    void notifyObservers(const QString& operation, const QVariant& data);
};
```

#### 4.1.2 播放状态读写锁
```cpp
class PlaybackStateManager : public QObject {
    Q_OBJECT
    
public:
    static PlaybackStateManager* instance();
    
    // 读操作
    AudioState getCurrentState() const;
    Song getCurrentSong() const;
    qint64 getCurrentPosition() const;
    qint64 getCurrentDuration() const;
    int getCurrentVolume() const;
    bool isMuted() const;
    PlayMode getPlayMode() const;
    
    // 写操作
    void setCurrentState(AudioState state);
    void setCurrentSong(const Song& song);
    void setCurrentPosition(qint64 position);
    void setCurrentDuration(qint64 duration);
    void setCurrentVolume(int volume);
    void setMuted(bool muted);
    void setPlayMode(PlayMode mode);
    
    // 原子操作
    void updatePlaybackInfo(const Song& song, qint64 position, qint64 duration);
    void updateVolumeInfo(int volume, bool muted);
    
signals:
    void stateChanged(AudioState state);
    void currentSongChanged(const Song& song);
    void positionChanged(qint64 position);
    void durationChanged(qint64 duration);
    void volumeChanged(int volume);
    void mutedChanged(bool muted);
    void playModeChanged(PlayMode mode);
    
private:
    PlaybackStateManager(QObject* parent = nullptr);
    static PlaybackStateManager* m_instance;
    
    mutable QReadWriteLock m_stateLock;
    
    AudioState m_currentState;
    Song m_currentSong;
    qint64 m_currentPosition;
    qint64 m_currentDuration;
    int m_currentVolume;
    bool m_muted;
    PlayMode m_playMode;
    
    void emitStateChanged();
};
```

### 4.2 条件变量

#### 4.2.1 音频缓冲区同步
```cpp
class AudioBuffer : public QObject {
    Q_OBJECT
    
public:
    explicit AudioBuffer(int bufferSize = 1024 * 1024, QObject* parent = nullptr);
    ~AudioBuffer();
    
    // 生产者接口
    bool writeData(const QByteArray& data, int timeoutMs = -1);
    bool writeDataNonBlocking(const QByteArray& data);
    
    // 消费者接口
    QByteArray readData(int size, int timeoutMs = -1);
    QByteArray readDataNonBlocking(int size);
    
    // 缓冲区状态
    int availableBytes() const;
    int freeBytes() const;
    bool isFull() const;
    bool isEmpty() const;
    void clear();
    
    // 缓冲区配置
    void setBufferSize(int size);
    int bufferSize() const;
    void setLowWaterMark(int bytes);
    void setHighWaterMark(int bytes);
    
signals:
    void bufferFull();
    void bufferEmpty();
    void lowWaterMarkReached();
    void highWaterMarkReached();
    void dataAvailable();
    void spaceAvailable();
    
private:
    mutable QMutex m_mutex;
    QWaitCondition m_notEmpty;
    QWaitCondition m_notFull;
    
    QByteArray m_buffer;
    int m_bufferSize;
    int m_readPos;
    int m_writePos;
    int m_dataSize;
    
    int m_lowWaterMark;
    int m_highWaterMark;
    
    bool m_shutdown;
    
    void checkWaterMarks();
    void emitSignals();
};
```

### 4.3 原子操作

#### 4.3.1 线程安全计数器
```cpp
class ThreadSafeCounter {
public:
    ThreadSafeCounter(int initialValue = 0) : m_value(initialValue) {}
    
    int increment() {
        return m_value.fetchAndAddOrdered(1) + 1;
    }
    
    int decrement() {
        return m_value.fetchAndAddOrdered(-1) - 1;
    }
    
    int add(int value) {
        return m_value.fetchAndAddOrdered(value) + value;
    }
    
    int subtract(int value) {
        return m_value.fetchAndAddOrdered(-value) - value;
    }
    
    int value() const {
        return m_value.loadAcquire();
    }
    
    void setValue(int value) {
        m_value.storeRelease(value);
    }
    
    bool compareAndSwap(int expected, int newValue) {
        return m_value.testAndSetOrdered(expected, newValue);
    }
    
private:
    QAtomicInt m_value;
};
```

#### 4.3.2 原子布尔标志
```cpp
class AtomicFlags {
public:
    AtomicFlags() : m_flags(0) {}
    
    void setFlag(int flag) {
        m_flags.fetchAndOrOrdered(1 << flag);
    }
    
    void clearFlag(int flag) {
        m_flags.fetchAndAndOrdered(~(1 << flag));
    }
    
    bool testFlag(int flag) const {
        return (m_flags.loadAcquire() & (1 << flag)) != 0;
    }
    
    void toggleFlag(int flag) {
        m_flags.fetchAndXorOrdered(1 << flag);
    }
    
    int allFlags() const {
        return m_flags.loadAcquire();
    }
    
    void setAllFlags(int flags) {
        m_flags.storeRelease(flags);
    }
    
    void clearAllFlags() {
        m_flags.storeRelease(0);
    }
    
private:
    QAtomicInt m_flags;
};
```

## 5. 性能优化策略

### 5.1 线程池管理

#### 5.1.1 动态线程池
```cpp
class DynamicThreadPool : public QObject {
    Q_OBJECT
    
public:
    explicit DynamicThreadPool(QObject* parent = nullptr);
    ~DynamicThreadPool();
    
    // 线程池配置
    void setMinThreadCount(int minThreads);
    void setMaxThreadCount(int maxThreads);
    void setIdleTimeout(int timeoutMs);
    
    // 任务提交
    void submitTask(std::function<void()> task, int priority = 0);
    QFuture<void> submitTaskAsync(std::function<void()> task, int priority = 0);
    
    template<typename T>
    QFuture<T> submitTaskWithResult(std::function<T()> task, int priority = 0);
    
    // 线程池状态
    int activeThreadCount() const;
    int idleThreadCount() const;
    int totalThreadCount() const;
    int pendingTaskCount() const;
    
    // 线程池控制
    void start();
    void stop();
    void waitForFinished();
    
signals:
    void threadCreated(QThread* thread);
    void threadDestroyed(QThread* thread);
    void taskStarted(int taskId);
    void taskFinished(int taskId);
    void allTasksFinished();
    
private:
    struct Task {
        std::function<void()> function;
        int priority;
        int taskId;
        QDateTime submitTime;
    };
    
    int m_minThreadCount;
    int m_maxThreadCount;
    int m_idleTimeout;
    
    QList<QThread*> m_threads;
    PriorityMessageQueue<Task> m_taskQueue;
    
    QMutex m_threadsMutex;
    QAtomicInt m_activeThreads;
    QAtomicInt m_nextTaskId;
    
    bool m_running;
    
    void createThread();
    void destroyThread(QThread* thread);
    void adjustThreadCount();
    void threadWorker();
};
```

### 5.2 内存优化

#### 5.2.1 内存池分配器
```cpp
template<typename T>
class MemoryPool {
public:
    MemoryPool(int blockSize = 1024, int initialBlocks = 10)
        : m_blockSize(blockSize), m_totalBlocks(0) {
        allocateBlocks(initialBlocks);
    }
    
    ~MemoryPool() {
        cleanup();
    }
    
    T* allocate() {
        QMutexLocker locker(&m_mutex);
        
        if (m_freeBlocks.isEmpty()) {
            allocateBlocks(m_blockSize);
        }
        
        T* block = m_freeBlocks.takeLast();
        m_usedBlocks.insert(block);
        return block;
    }
    
    void deallocate(T* block) {
        QMutexLocker locker(&m_mutex);
        
        if (m_usedBlocks.contains(block)) {
            m_usedBlocks.remove(block);
            m_freeBlocks.append(block);
        }
    }
    
    int freeBlockCount() const {
        QMutexLocker locker(&m_mutex);
        return m_freeBlocks.size();
    }
    
    int usedBlockCount() const {
        QMutexLocker locker(&m_mutex);
        return m_usedBlocks.size();
    }
    
    int totalBlockCount() const {
        QMutexLocker locker(&m_mutex);
        return m_totalBlocks;
    }
    
private:
    int m_blockSize;
    int m_totalBlocks;
    
    QList<T*> m_freeBlocks;
    QSet<T*> m_usedBlocks;
    QList<T*> m_allBlocks;
    
    mutable QMutex m_mutex;
    
    void allocateBlocks(int count) {
        for (int i = 0; i < count; ++i) {
            T* block = new T;
            m_freeBlocks.append(block);
            m_allBlocks.append(block);
        }
        m_totalBlocks += count;
    }
    
    void cleanup() {
        QMutexLocker locker(&m_mutex);
        for (T* block : m_allBlocks) {
            delete block;
        }
        m_allBlocks.clear();
        m_freeBlocks.clear();
        m_usedBlocks.clear();
        m_totalBlocks = 0;
    }
};
```

### 5.3 缓存优化

#### 5.3.1 LRU缓存实现
```cpp
template<typename K, typename V>
class LRUCache {
public:
    explicit LRUCache(int capacity = 100) : m_capacity(capacity) {}
    
    void insert(const K& key, const V& value) {
        QMutexLocker locker(&m_mutex);
        
        auto it = m_map.find(key);
        if (it != m_map.end()) {
            // 更新现有项
            m_list.erase(it->second);
            m_list.push_front(std::make_pair(key, value));
            it->second = m_list.begin();
        } else {
            // 插入新项
            if (m_map.size() >= m_capacity) {
                // 移除最久未使用的项
                auto last = m_list.back();
                m_map.erase(last.first);
                m_list.pop_back();
            }
            
            m_list.push_front(std::make_pair(key, value));
            m_map[key] = m_list.begin();
        }
    }
    
    bool get(const K& key, V& value) {
        QMutexLocker locker(&m_mutex);
        
        auto it = m_map.find(key);
        if (it != m_map.end()) {
            // 移动到前面
            value = it->second->second;
            m_list.splice(m_list.begin(), m_list, it->second);
            return true;
        }
        return false;
    }
    
    bool contains(const K& key) const {
        QMutexLocker locker(&m_mutex);
        return m_map.find(key) != m_map.end();
    }
    
    void remove(const K& key) {
        QMutexLocker locker(&m_mutex);
        
        auto it = m_map.find(key);
        if (it != m_map.end()) {
            m_list.erase(it->second);
            m_map.erase(it);
        }
    }
    
    void clear() {
        QMutexLocker locker(&m_mutex);
        m_map.clear();
        m_list.clear();
    }
    
    int size() const {
        QMutexLocker locker(&m_mutex);
        return m_map.size();
    }
    
    int capacity() const {
        return m_capacity;
    }
    
    void setCapacity(int capacity) {
        QMutexLocker locker(&m_mutex);
        m_capacity = capacity;
        
        // 如果当前大小超过新容量，移除多余项
        while (m_map.size() > m_capacity) {
            auto last = m_list.back();
            m_map.erase(last.first);
            m_list.pop_back();
        }
    }
    
private:
    int m_capacity;
    mutable QMutex m_mutex;
    
    std::list<std::pair<K, V>> m_list;
    std::unordered_map<K, typename std::list<std::pair<K, V>>::iterator> m_map;
};
```

## 6. 错误处理与监控

### 6.1 线程异常处理

#### 6.1.1 线程异常管理器
```cpp
class ThreadExceptionHandler : public QObject {
    Q_OBJECT
    
public:
    static ThreadExceptionHandler* instance();
    
    // 异常处理
    void handleException(QThread* thread, const std::exception& e);
    void handleUnknownException(QThread* thread);
    
    // 异常监控
    void installExceptionHandler(QThread* thread);
    void removeExceptionHandler(QThread* thread);
    
    // 异常恢复
    void setRecoveryStrategy(const QString& threadName, std::function<void()> recovery);
    void executeRecovery(const QString& threadName);
    
    // 异常统计
    int getExceptionCount(const QString& threadName) const;
    QStringList getThreadsWithExceptions() const;
    
signals:
    void exceptionOccurred(const QString& threadName, const QString& error);
    void threadRecovered(const QString& threadName);
    void threadFailed(const QString& threadName);
    
private:
    ThreadExceptionHandler(QObject* parent = nullptr);
    static ThreadExceptionHandler* m_instance;
    
    struct ExceptionInfo {
        QString threadName;
        QString error;
        QDateTime timestamp;
        int count;
    };
    
    QMap<QString, ExceptionInfo> m_exceptions;
    QMap<QString, std::function<void()>> m_recoveryStrategies;
    QSet<QThread*> m_monitoredThreads;
    
    QMutex m_exceptionMutex;
    
    void logException(const QString& threadName, const QString& error);
    QString getThreadName(QThread* thread);
};
```

### 6.2 性能监控

#### 6.2.1 线程性能监控器
```cpp
class ThreadPerformanceMonitor : public QObject {
    Q_OBJECT
    
public:
    static ThreadPerformanceMonitor* instance();
    
    // 性能监控
    void startMonitoring(QThread* thread, const QString& threadName);
    void stopMonitoring(QThread* thread);
    
    // 性能指标
    void recordTaskExecution(const QString& threadName, const QString& taskName, qint64 duration);
    void recordMemoryUsage(const QString& threadName, qint64 bytes);
    void recordCPUUsage(const QString& threadName, double percentage);
    
    // 性能报告
    QVariantMap getPerformanceReport(const QString& threadName) const;
    QVariantMap getAllPerformanceReports() const;
    
    // 性能告警
    void setPerformanceThreshold(const QString& metric, double threshold);
    void checkPerformanceThresholds();
    
signals:
    void performanceAlert(const QString& threadName, const QString& metric, double value);
    void performanceReportReady(const QString& threadName, const QVariantMap& report);
    
private:
    ThreadPerformanceMonitor(QObject* parent = nullptr);
    static ThreadPerformanceMonitor* m_instance;
    
    struct PerformanceMetrics {
        QString threadName;
        QList<qint64> taskDurations;
        QList<qint64> memoryUsages;
        QList<double> cpuUsages;
        QDateTime lastUpdate;
        int taskCount;
        qint64 totalDuration;
        qint64 maxMemoryUsage;
        double maxCPUUsage;
    };
    
    QMap<QString, PerformanceMetrics> m_metrics;
    QMap<QString, double> m_thresholds;
    QSet<QThread*> m_monitoredThreads;
    
    QMutex m_metricsMutex;
    QTimer* m_reportTimer;
    
    void generatePerformanceReport(const QString& threadName);
    void cleanupOldMetrics();
};
```

## 7. 线程生命周期管理

### 7.1 线程管理器

#### 7.1.1 应用线程管理器
```cpp
class ApplicationThreadManager : public QObject {
    Q_OBJECT
    
public:
    static ApplicationThreadManager* instance();
    
    // 线程创建
    QThread* createThread(const QString& threadName, ThreadType type);
    void destroyThread(const QString& threadName);
    
    // 线程控制
    void startThread(const QString& threadName);
    void stopThread(const QString& threadName);
    void pauseThread(const QString& threadName);
    void resumeThread(const QString& threadName);
    
    // 线程查询
    QThread* getThread(const QString& threadName) const;
    QStringList getThreadNames() const;
    ThreadStatus getThreadStatus(const QString& threadName) const;
    
    // 线程监控
    void enableThreadMonitoring(const QString& threadName);
    void disableThreadMonitoring(const QString& threadName);
    
    // 应用程序关闭
    void shutdownAllThreads();
    void waitForAllThreadsFinished(int timeoutMs = 5000);
    
signals:
    void threadCreated(const QString& threadName);
    void threadDestroyed(const QString& threadName);
    void threadStarted(const QString& threadName);
    void threadStopped(const QString& threadName);
    void threadError(const QString& threadName, const QString& error);
    
private:
    ApplicationThreadManager(QObject* parent = nullptr);
    static ApplicationThreadManager* m_instance;
    
    struct ThreadInfo {
        QThread* thread;
        QString name;
        ThreadType type;
        ThreadStatus status;
        QDateTime createdTime;
        QDateTime lastActiveTime;
        bool monitored;
    };
    
    QMap<QString, ThreadInfo> m_threads;
    QMutex m_threadsMutex;
    
    QTimer* m_monitoringTimer;
    
    void setupThreadMonitoring();
    void monitorThreads();
    void handleThreadFinished();
};
```

### 7.2 线程状态机

#### 7.2.1 线程状态管理
```cpp
class ThreadStateMachine : public QStateMachine {
    Q_OBJECT
    
public:
    explicit ThreadStateMachine(QThread* thread, QObject* parent = nullptr);
    
    // 状态查询
    bool isInState(ThreadState state) const;
    ThreadState currentState() const;
    
    // 状态转换
    void requestStart();
    void requestStop();
    void requestPause();
    void requestResume();
    void requestTerminate();
    
signals:
    void stateChanged(ThreadState oldState, ThreadState newState);
    void stateTransitionFailed(ThreadState fromState, ThreadState toState);
    
private slots:
    void onStateEntered();
    void onStateExited();
    void onTransitionTriggered();
    
private:
    QThread* m_thread;
    
    // 状态定义
    QState* m_initialState;
    QState* m_runningState;
    QState* m_pausedState;
    QState* m_stoppedState;
    QState* m_terminatedState;
    
    // 转换定义
    QSignalTransition* m_startTransition;
    QSignalTransition* m_stopTransition;
    QSignalTransition* m_pauseTransition;
    QSignalTransition* m_resumeTransition;
    QSignalTransition* m_terminateTransition;
    
    void setupStates();
    void setupTransitions();
    void connectSignals();
};
```

## 8. 调试与测试

### 8.1 线程调试工具

#### 8.1.1 线程调试器
```cpp
class ThreadDebugger : public QObject {
    Q_OBJECT
    
public:
    static ThreadDebugger* instance();
    
    // 调试控制
    void enableDebugging(bool enabled);
    void setDebugLevel(DebugLevel level);
    
    // 线程跟踪
    void traceThread(const QString& threadName);
    void untraceThread(const QString& threadName);
    
    // 死锁检测
    void enableDeadlockDetection(bool enabled);
    void checkForDeadlocks();
    
    // 调试信息
    void logThreadInfo(const QString& threadName, const QString& message);
    void logThreadState(const QString& threadName, ThreadState state);
    void logThreadLock(const QString& threadName, const QString& lockName);
    
    // 调试报告
    QString generateDebugReport() const;
    void saveDebugReport(const QString& filePath) const;
    
signals:
    void debugMessageGenerated(const QString& message);
    void deadlockDetected(const QStringList& threadNames);
    void threadStateChanged(const QString& threadName, ThreadState state);
    
private:
    ThreadDebugger(QObject* parent = nullptr);
    static ThreadDebugger* m_instance;
    
    struct DebugInfo {
        QString threadName;
        QStringList messages;
        QDateTime lastActivity;
        ThreadState currentState;
        QStringList heldLocks;
    };
    
    bool m_debuggingEnabled;
    DebugLevel m_debugLevel;
    bool m_deadlockDetectionEnabled;
    
    QMap<QString, DebugInfo> m_debugInfo;
    QSet<QString> m_tracedThreads;
    
    mutable QMutex m_debugMutex;
    
    void performDeadlockDetection();
    void logDebugMessage(const QString& message);
};
```

### 8.2 多线程单元测试

#### 8.2.1 线程测试框架
```cpp
class ThreadTestFramework : public QObject {
    Q_OBJECT
    
public:
    explicit ThreadTestFramework(QObject* parent = nullptr);
    
    // 测试环境
    void setupTestEnvironment();
    void cleanupTestEnvironment();
    
    // 线程测试
    void testThreadCreation();
    void testThreadDestruction();
    void testThreadCommunication();
    void testThreadSynchronization();
    void testThreadException();
    
    // 性能测试
    void testThreadPerformance();
    void testConcurrentAccess();
    void testLoadTesting();
    
    // 压力测试
    void stressTestThreads(int threadCount, int duration);
    void stressTestSynchronization(int iterations);
    
private slots:
    void onTestFinished();
    void onTestFailed(const QString& error);
    
private:
    QList<QThread*> m_testThreads;
    QList<std::function<void()>> m_testFunctions;
    
    int m_passedTests;
    int m_failedTests;
    int m_totalTests;
    
    void executeTest(const QString& testName, std::function<void()> testFunction);
    void verifyResult(const QString& testName, bool result);
    void logTestResult(const QString& testName, bool passed, const QString& error = QString());
};
```

## 9. 配置与优化

### 9.1 线程配置

#### 9.1.1 线程配置管理器
```cpp
class ThreadConfigManager : public QObject {
    Q_OBJECT
    
public:
    static ThreadConfigManager* instance();
    
    // 配置加载
    void loadConfiguration(const QString& configFile);
    void saveConfiguration(const QString& configFile);
    
    // 线程配置
    void setThreadPriority(const QString& threadName, QThread::Priority priority);
    void setThreadStackSize(const QString& threadName, int stackSize);
    void setThreadAffinity(const QString& threadName, int cpuCore);
    
    // 线程池配置
    void setThreadPoolSize(const QString& poolName, int size);
    void setThreadPoolTimeout(const QString& poolName, int timeout);
    
    // 性能配置
    void setPerformanceMode(PerformanceMode mode);
    void optimizeForCPUCount(int cpuCount);
    void optimizeForMemorySize(qint64 memorySize);
    
    // 配置查询
    QVariant getThreadConfig(const QString& threadName, const QString& key) const;
    QVariantMap getAllThreadConfigs() const;
    
signals:
    void configurationLoaded();
    void configurationSaved();
    void configurationChanged(const QString& key, const QVariant& value);
    
private:
    ThreadConfigManager(QObject* parent = nullptr);
    static ThreadConfigManager* m_instance;
    
    QVariantMap m_threadConfigs;
    QVariantMap m_poolConfigs;
    QVariantMap m_performanceConfigs;
    
    QString m_configFile;
    
    void applyDefaultConfiguration();
    void applyThreadConfiguration(const QString& threadName);
    void applyPerformanceOptimizations();
};
```

## 10. 总结

### 10.1 多线程架构特点

本设计采用了**7个核心线程**构建的多线程架构：

1. **主线程**: UI处理和事件分发
2. **音频处理线程**: 音频播放和解码
3. **数据库操作线程**: 数据持久化
4. **音频分析线程**: 频谱分析和可视化
5. **文件I/O线程**: 文件操作和元数据提取
6. **缓存管理线程**: 内存缓存优化
7. **插件管理线程**: 插件生命周期管理

### 10.2 关键技术特色

#### 🔄 **通信机制**
- **信号槽**: Qt原生的线程安全通信
- **消息队列**: 优先级队列和线程安全队列
- **事件总线**: 发布订阅模式的事件分发

#### 🔒 **同步机制**
- **读写锁**: 高效的数据访问控制
- **条件变量**: 线程间的状态同步
- **原子操作**: 无锁编程优化

#### ⚡ **性能优化**
- **动态线程池**: 根据负载自动调整线程数
- **内存池**: 减少动态内存分配开销
- **LRU缓存**: 智能的数据缓存策略

#### 🛡️ **安全与健壮性**
- **异常处理**: 完整的线程异常管理
- **死锁检测**: 自动检测和预防死锁
- **性能监控**: 实时线程性能监控

### 10.3 设计优势

1. **高性能**: 多线程并行处理，充分利用多核CPU
2. **响应性**: UI线程独立，保证界面流畅
3. **可伸缩性**: 动态线程池，根据负载调整
4. **容错性**: 完善的异常处理和恢复机制
5. **可维护性**: 清晰的线程职责分工
6. **可扩展性**: 插件系统支持功能扩展

### 10.4 适用场景

- **多媒体应用**: 音频/视频播放器
- **实时数据处理**: 音频分析和可视化
- **大数据应用**: 文件扫描和元数据提取
- **后台服务**: 缓存管理和数据同步
- **插件系统**: 可扩展的功能模块

这个多线程设计确保了Qt6音频播放器在复杂的多线程环境下能够安全、高效、稳定地运行，为用户提供流畅的音频播放体验。

---

**版本**: 0.1  
**创建日期**: 2025年  
**最后更新**: 2025年  
**作者**: Qt6音频播放器开发团队
